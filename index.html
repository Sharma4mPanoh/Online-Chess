<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Online Chess — Stable + Timers + Eval</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg1:#0e1530; --bg2:#0a0f24; --panel:#141b38; --border:#2a3b6e; --txt:#eaf0ff;
      --sq-light:#9ec5ff;  /* light blue */
      --sq-dark:#2d4e85;   /* dark blue */
      --sel:#ffd166; --hint:#ffe28a; --move:#77e0ff; --check:#ff6b6b;
      --shadow:0 10px 30px rgba(0,0,0,.28); --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--txt);
      background: radial-gradient(1200px 1200px at 80% -10%, #1c2c66 0%, var(--bg1) 55%, var(--bg2) 100%) fixed;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }
    .container{max-width:1120px; margin:0 auto; padding:20px}
    .app{ display:grid; grid-template-columns: minmax(320px, 1fr) 360px; gap:18px }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr } }

    .left{
      background:linear-gradient(180deg,#1a2350,#11172f);
      border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:16px; display:grid; gap:12px; grid-template-rows: auto auto 1fr auto;
    }
    .right{
      background:linear-gradient(180deg,#151b3a,#0e142c);
      border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow);
      padding:16px; display:grid; gap:14px; align-content:start;
    }

    .bar{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap }
    .h1{ font-weight:700; letter-spacing:.3px; opacity:.95 }
    .controls, .timer-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .chip, select, button, input{
      background:var(--panel); color:var(--txt); border:1px solid var(--border);
      padding:8px 12px; border-radius:12px; font-weight:600;
    }
    button.primary{ background:#2a3569; border-color:#3451c7 }
    button:hover, select:hover, input:hover{ filter:brightness(1.08) }
    button:active{ transform:translateY(1px) }

    /* Board: fixed 8x8 grid, no jitter */
    .board-wrap{ display:grid; gap:10px }
    .board{
      width:100%; max-width: min(86vh, 720px);
      aspect-ratio: 1 / 1;               /* keep square when supported */
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr); /* ← important */
      border-radius:14px; overflow:hidden; border:2px solid var(--border); user-select:none;
      margin-inline:auto;
    }
    .sq{ position:relative; display:grid; place-items:center; cursor:pointer; }
    .light{ background: var(--sq-light) }
    .dark{  background: var(--sq-dark)  }
    .piece{ font-size: clamp(30px, 5vw, 56px); line-height:1; text-shadow: 0 1px 0 rgba(0,0,0,.35), 0 2px 4px rgba(0,0,0,.25) }
    .coord{ position:absolute; left:6px; top:5px; font-size:12px; opacity:.55; font-weight:700; color:#0a1127; mix-blend-mode: soft-light }
    .dark .coord{ color:#dfe8ff; opacity:.4; mix-blend-mode:normal }

    .sq.sel{ outline:3px solid var(--sel) }
    .sq.hint::after{ content:""; width:16px; height:16px; border-radius:50%; background:var(--hint); opacity:.95; box-shadow:0 0 0 4px rgba(0,0,0,.14) }
    .sq.move{ box-shadow: inset 0 0 0 4px rgba(119,224,255,.85) }
    .sq.check{ box-shadow: inset 0 0 0 4px var(--check) }

    .status{ background:#0e1430; border:1px solid var(--border); border-radius:12px; padding:10px; min-height:44px }
    .panel{ background:#0e1430; border:1px solid var(--border); border-radius:12px; padding:10px }

    .clocks{ display:grid; grid-template-columns: 1fr 1fr; gap:10px }
    .clock{ background:#0e1430; border:1px solid var(--border); border-radius:12px; padding:10px; text-align:center; font-variant-numeric: tabular-nums; }
    .clock.turn{ outline:2px solid #49c2ff; box-shadow:0 0 0 2px rgba(73,194,255,.25) inset }

    .moves{ height:260px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:13px; line-height:1.55; white-space:pre-wrap }
    .small{ font-size:12px; opacity:.75 }
  </style>
</head>
<body>
  <div class="container">
    <div class="app">
      <section class="left">
        <div class="bar">
          <div class="h1">♟ Online Chess</div>
          <div class="controls">
            <label class="chip">Side:
              <select id="side">
                <option value="white">White</option>
                <option value="black">Black</option>
              </select>
            </label>
            <label class="chip">Level:
              <select id="level">
                <option value="beginner">Beginner</option>
                <option value="expert" selected>Expert</option>
              </select>
            </label>
            <button id="new" class="primary">New Game</button>
            <button id="undo">Undo</button>
            <button id="flip">Flip</button>
          </div>
        </div>

        <!-- Timer controls -->
        <div class="timer-row">
          <label class="chip">Timer:
            <select id="timeControl">
              <option value="0">Off</option>
              <option value="60">1 min</option>
              <option value="180">3 min</option>
              <option value="300" selected>5 min</option>
              <option value="600">10 min</option>
            </select>
          </label>
          <button id="startPause">Start</button>
          <button id="resetClock">Reset Clock</button>
        </div>

        <!-- Board -->
        <div class="board-wrap">
          <div id="board" class="board" aria-label="Chessboard"></div>
        </div>

        <!-- Status + Eval -->
        <div class="bar">
          <div id="evalWrap" class="chip">Eval: <span id="eval">—</span></div>
          <div id="status" class="status">Welcome! Choose side & level, then press <b>New Game</b>.</div>
        </div>
      </section>

      <aside class="right">
        <div class="clocks">
          <div id="clockW" class="clock">White ⏱ <div id="cw">05:00.0</div></div>
          <div id="clockB" class="clock">Black ⏱ <div id="cb">05:00.0</div></div>
        </div>
        <div class="panel">
          <b>Captured</b>
          <div id="captured" style="margin-top:6px;font-size:22px;display:flex;gap:6px;flex-wrap:wrap"></div>
        </div>
        <div class="panel">
          <b>Move List</b>
          <div id="moves" class="moves" aria-live="polite"></div>
        </div>
        <div class="small">Tip: Pieces are black/white Unicode on dark/light blue squares. Click a piece, then a highlighted square. Promotions will ask what you want.</div>
      </aside>
    </div>
  </div>

  <!-- Promotion modal (has prompt() fallback) -->
  <dialog id="promoDialog">
    <div style="padding:14px 16px; display:grid; gap:12px">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <strong>Choose promotion</strong>
        <button id="cancelPromo" class="chip">Cancel</button>
      </div>
      <div class="promo-grid" id="promoGrid" style="display:grid;grid-template-columns:repeat(4,60px);gap:8px;justify-content:center"></div>
    </div>
  </dialog>

  <script>
    /* ---------------- Safe utilities ---------------- */
    const safeClone = (obj) =>
      (typeof window.structuredClone === "function")
        ? window.structuredClone(obj)
        : JSON.parse(JSON.stringify(obj));
    const hasDialog = typeof HTMLDialogElement !== "undefined";

    /* ---------------- Chess Core ---------------- */
    const PIECE_TO_CHAR = { wP:'♙', wN:'♘', wB:'♗', wR:'♖', wQ:'♕', wK:'♔', bP:'♟', bN:'♞', bB:'♝', bR:'♜', bQ:'♛', bK:'♚' };
    const PIECE_VALUE = { P:100, N:320, B:330, R:500, Q:900, K:20000 };
    const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    const PST = {
      P:[0,0,0,0,0,0,0,0,50,50,50,50,50,50,50,50,10,10,20,30,30,20,10,10,5,5,10,25,25,10,5,5,0,0,0,20,20,0,0,0,5,-5,-10,0,0,-10,-5,5,5,10,10,-20,-20,10,10,5,0,0,0,0,0,0,0,0],
      N:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
      B:[-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
      R:[0,0,0,5,5,0,0,0,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,5,10,10,10,10,10,10,5,0,0,0,0,0,0,0,0],
      Q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
      K:[-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10,20,20,0,0,0,0,20,20,20,30,10,0,0,10,30,20]
    };
    const idx=(r,c)=>r*8+c, inb=(r,c)=>r>=0&&r<8&&c>=0&&c<8, alg=(r,c)=>"abcdefgh"[c]+(8-r), opp=c=>c==='w'?'b':'w';
    const coordOf = sq => [8-parseInt(sq[1]), "abcdefgh".indexOf(sq[0])];
    const pieceAt=(S,r,c)=>S.board[idx(r,c)];
    const put=(S,r,c,p)=>{S.board[idx(r,c)]=p};

    function fenToState(f){
      const [piece,turn,cast,ep,half,full]=f.split(/\s+/);
      const board=Array(64).fill(null), rows=piece.split('/');
      rows.forEach((row,r)=>{ let c=0; for(const ch of row){ if(/\d/.test(ch)) c+=+ch; else { const clr=(ch===ch.toUpperCase())?'w':'b'; board[idx(r,c)]=clr+ch.toUpperCase(); c++; } }});
      const cr={wK:false,wQ:false,bK:false,bQ:false}; if(cast.includes('K'))cr.wK=true; if(cast.includes('Q'))cr.wQ=true; if(cast.includes('k'))cr.bK=true; if(cast.includes('q'))cr.bQ=true;
      return {board, turn, castling:cr, ep: ep==='-'?null:ep, halfmove:+(half||0), fullmove:+(full||1), history:[], lastMove:null};
    }
    function isAttacked(S,[tr,tc],by){
      const dir=by==='w'?-1:1;
      for(const dc of [-1,1]){ const r=tr+dir,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'P')) return true; }
      for(const [dr,dc] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const r=tr+dr,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'N')) return true; }
      const diag=[[1,1],[1,-1],[-1,1],[-1,-1]]; for(const [dr,dc] of diag){ let r=tr+dr,c=tc+dc; while(inb(r,c)){ const p=pieceAt(S,r,c); if(p){ if(p[0]===by && (p[1]==='B'||p[1]==='Q')) return true; break;} r+=dr;c+=dc; } }
      const stra=[[1,0],[-1,0],[0,1],[0,-1]]; for(const [dr,dc] of stra){ let r=tr+dr,c=tc+dc; while(inb(r,c)){ const p=pieceAt(S,r,c); if(p){ if(p[0]===by && (p[1]==='R'||p[1]==='Q')) return true; break;} r+=dr;c+=dc; } }
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc)continue; const r=tr+dr,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'K')) return true; }
      return false;
    }
    function inCheck(S,who){ for(let r=0;r<8;r++)for(let c=0;c<8;c++){ if(pieceAt(S,r,c)===(who+'K')) return isAttacked(S,[r,c],opp(who)); } return false; }

    function allMoves(S){
      const out=[];
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const p=pieceAt(S,r,c); if(!p||p[0]!==S.turn) continue;
        const t=p[1];
        if(t==='P'){ const dir=S.turn==='w'?-1:1, start=S.turn==='w'?6:1, last=S.turn==='w'?0:7;
          if(inb(r+dir,c)&&!pieceAt(S,r+dir,c)){ pushPawn(r,c,r+dir,c); if(r===start && !pieceAt(S,r+2*dir,c)) out.push({from:[r,c],to:[r+2*dir,c],pawn2:true}); }
          for(const dc of [-1,1]){ const nr=r+dir,nc=c+dc; if(!inb(nr,nc))continue; const q=pieceAt(S,nr,nc); if(q&&q[0]!==S.turn) pushPawn(r,c,nr,nc,q); }
          if(S.ep){ const [er,ec]=coordOf(S.ep); if(er===r+dir && Math.abs(ec-c)===1) out.push({from:[r,c],to:[er,ec],ep:true}); }
          function pushPawn(fr,fc,tr,tc,captured=null){ const promo=tr===last; if(promo){ for(const pp of ['Q','R','B','N']) out.push({from:[fr,fc],to:[tr,tc],captured,promo:pp}); } else out.push({from:[fr,fc],to:[tr,tc],captured}); }
        } else if(t==='N'){
          for(const [dr,dc] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const nr=r+dr,nc=c+dc; if(!inb(nr,nc))continue; const q=pieceAt(S,nr,nc); if(!q||q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q||null}); }
        } else if(t==='B'||t==='R'||t==='Q'){
          const dirs=t==='B'?[[1,1],[1,-1],[-1,1],[-1,-1]]:t==='R'?[[1,0],[-1,0],[0,1],[0,-1]]:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(inb(nr,nc)){ const q=pieceAt(S,nr,nc); if(!q) out.push({from:[r,c],to:[nr,nc]}); else { if(q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q}); break; } nr+=dr; nc+=dc; } }
        } else if(t==='K'){
          for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc)continue; const nr=r+dr,nc=c+dc; if(!inb(nr,nc))continue; const q=pieceAt(S,nr,nc); if(!q||q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q||null}); }
          const clr=S.turn, back=clr==='w'?7:0;
          if(r===back&&c===4){
            if((clr==='w'&&S.castling.wK)||(clr==='b'&&S.castling.bK)){
              if(!pieceAt(S,back,5)&&!pieceAt(S,back,6)&&!isAttacked(S,[back,4],opp(clr))&&!isAttacked(S,[back,5],opp(clr))&&!isAttacked(S,[back,6],opp(clr))) out.push({from:[back,4],to:[back,6],castle:'K'});
            }
            if((clr==='w'&&S.castling.wQ)||(clr==='b'&&S.castling.bQ)){
              if(!pieceAt(S,back,3)&&!pieceAt(S,back,2)&&!pieceAt(S,back,1)&&!isAttacked(S,[back,4],opp(clr))&&!isAttacked(S,[back,3],opp(clr))&&!isAttacked(S,[back,2],opp(clr))) out.push({from:[back,4],to:[back,2],castle:'Q'});
            }
          }
        }
      }
      const legal=[];
      for(const m of out){ doMove(S,m); const illegal=inCheck(S,opp(S.turn)); undoMove(S); if(!illegal) legal.push(m); }
      return legal;
    }
    function doMove(S,m){
      S.history.push({board:S.board.slice(), turn:S.turn, castling:{...S.castling}, ep:S.ep, halfmove:S.halfmove, fullmove:S.fullmove, lastMove:m});
      const [fr,fc]=m.from,[tr,tc]=m.to; const moving=pieceAt(S,fr,fc), target=pieceAt(S,tr,tc);
      if(moving[1]==='P'||target) S.halfmove=0; else S.halfmove++;
      if(S.ep){ const [er,ec]=coordOf(S.ep); if(m.ep&&tr===er&&tc===ec){ const capr=S.turn==='w'?tr+1:tr-1; put(S,capr,tc,null); } }
      put(S,tr,tc,moving); put(S,fr,fc,null);
      if(m.castle==='K'){ const back=S.turn==='w'?7:0; const rook=pieceAt(S,back,7); put(S,back,5,rook); put(S,back,7,null); }
      else if(m.castle==='Q'){ const back=S.turn==='w'?7:0; const rook=pieceAt(S,back,0); put(S,back,3,rook); put(S,back,0,null); }
      if(m.promo) put(S,tr,tc,S.turn+m.promo);
      if(moving==='wK'){S.castling.wK=false;S.castling.wQ=false}
      if(moving==='bK'){S.castling.bK=false;S.castling.bQ=false}
      if(moving==='wR'){ if(fr===7&&fc===0)S.castling.wQ=false; if(fr===7&&fc===7)S.castling.wK=false }
      if(moving==='bR'){ if(fr===0&&fc===0)S.castling.bQ=false; if(fr===0&&fc===7)S.castling.bK=false }
      if(target==='wR'){ if(tr===7&&tc===0)S.castling.wQ=false; if(tr===7&&tc===7)S.castling.wK=false }
      if(target==='bR'){ if(tr===0&&tc===0)S.castling.bQ=false; if(tr===0&&tc===7)S.castling.bK=false }
      S.ep = m.pawn2 ? alg(S.turn==='w'?tr+1:tr-1, tc) : null;
      if(S.turn==='b') S.fullmove++; S.turn=opp(S.turn); S.lastMove={...m};
    }
    function undoMove(S){ const h=S.history.pop(); if(!h) return; Object.assign(S,{board:h.board,turn:h.turn,castling:h.castling,ep:h.ep,halfmove:h.halfmove,fullmove:h.fullmove,lastMove:h.lastMove}); }
    function evaluate(S){
      let sc=0;
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){
        const p=pieceAt(S,r,c); if(!p) continue;
        const s=p[0]==='w'?1:-1, t=p[1];
        sc += s*PIECE_VALUE[t];
        sc += (p[0]==='w' ? PST[t][r*8+c] : -PST[t][(7-r)*8+c]);
      }
      const t=S.turn, ms=allMoves(S).length; S.turn=opp(S.turn); const os=allMoves(S).length; S.turn=t; sc += 2*(ms-os);
      return sc;
    }
    function formatEval(cp){ const pawns=(cp/100).toFixed(2); return (cp>=0?'+':'')+pawns; }

    function pickMove(S, level){
      const moves=allMoves(S); if(!moves.length) return null;
      if(level==='beginner'){ const caps=moves.filter(m=>m.captured); return (caps.length?caps:moves)[Math.floor(Math.random()*(caps.length?caps.length:moves.length))]; }
      const depth=3; let best=-1e9, choice=moves[0];
      order(moves);
      for(const m of moves){ doMove(S,m); const sc=-ab(S,depth-1,-1e9,1e9); undoMove(S); if(sc>best){best=sc; choice=m;} }
      lastEval=best; return choice;
      function ab(S,d,a,b){ const mv=allMoves(S); if(d===0||!mv.length) return q(S,a,b,8); order(mv); let v=-1e9; for(const m of mv){ doMove(S,m); v=Math.max(v,-ab(S,d-1,-b,-a)); undoMove(S); if(v>=b) return v; if(v>a) a=v; } return v; }
      function q(S,a,b,bud){ const stand=evaluate(S); if(stand>=b) return stand; if(a<stand)a=stand; if(bud<=0) return stand; const caps=allMoves(S).filter(m=>m.captured); order(caps); for(const m of caps){ doMove(S,m); const s=-q(S,-b,-a,bud-1); undoMove(S); if(s>=b) return s; if(s>a)a=s; } return a; }
      function order(mv){ mv.sort((A,B)=>score(B)-score(A)); function v(p){return p?PIECE_VALUE[p[1]]:0} function score(m){ let s=0; if(m.captured)s+=1000+v(m.captured); if(m.promo)s+=800+PIECE_VALUE[m.promo]; if(m.castle)s+=200; return s; } }
    }

    /* ---------------- UI / State ---------------- */
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const evalEl = document.getElementById('eval');
    const movesEl = document.getElementById('moves');
    const capturedEl = document.getElementById('captured');
    const levelSel = document.getElementById('level');
    const sideSel = document.getElementById('side');
    const timeSel = document.getElementById('timeControl');
    const newBtn = document.getElementById('new');
    const undoBtn = document.getElementById('undo');
    const flipBtn = document.getElementById('flip');
    const startPauseBtn = document.getElementById('startPause');
    const resetClockBtn = document.getElementById('resetClock');
    const promoDialog = document.getElementById('promoDialog');
    const promoGrid = document.getElementById('promoGrid');
    const cancelPromo = document.getElementById('cancelPromo');
    const clockW = document.getElementById('clockW');
    const clockB = document.getElementById('clockB');
    const cw = document.getElementById('cw');
    const cb = document.getElementById('cb');

    let S = fenToState(START_FEN);
    let selected=null, hints=[], whiteBottom=true, lastEval=null, humanColor='w';

    // --- Board size fallback: keep height = width even if aspect-ratio fails ---
    function sizeBoard(){
      const w = boardEl.getBoundingClientRect().width;
      if (w > 0) boardEl.style.height = w + 'px';
    }
    window.addEventListener('resize', sizeBoard);
    try { new ResizeObserver(sizeBoard).observe(boardEl); } catch(e) {}
    sizeBoard();

    // Clocks
    let clock = { w: 300000, b: 300000 }; // ms
    let running = false;
    let lastTick = null;
    function setBaseClock(seconds){
      clock.w = seconds*1000;
      clock.b = seconds*1000;
      updateClockDom();
    }
    function updateClockDom(){
      function fmt(ms){ ms=Math.max(0,ms); const m=Math.floor(ms/60000), s=Math.floor((ms%60000)/1000), d=Math.floor((ms%1000)/100); return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${d}` }
      cw.textContent = fmt(clock.w);
      cb.textContent = fmt(clock.b);
      clockW.classList.toggle('turn', S.turn==='w' && running);
      clockB.classList.toggle('turn', S.turn==='b' && running);
    }
    function tick(ts){
      if(!running){ lastTick=null; return; }
      if(lastTick==null) lastTick=ts;
      const dt = ts - lastTick; lastTick = ts;
      if(S.turn==='w') clock.w -= dt; else clock.b -= dt;
      if(clock.w<=0 || clock.b<=0){
        running=false; updateClockDom();
        const loser = (clock.w<=0)?'White':'Black';
        statusEl.innerHTML = `<b>Time out.</b> ${loser} loses on time.`;
        return;
      }
      updateClockDom();
      requestAnimationFrame(tick);
    }
    function startClock(){ if(timeSel.value==='0'){ running=false; updateClockDom(); return; } if(!running){ running=true; requestAnimationFrame(tick); } startPauseBtn.textContent='Pause'; }
    function pauseClock(){ running=false; startPauseBtn.textContent='Start'; updateClockDom(); }
    function resetClock(){ setBaseClock(+timeSel.value||0); pauseClock(); }

    function status(html){ statusEl.innerHTML = html; }
    const orient = (r,c)=> whiteBottom?[r,c]:[7-r,7-c];
    const deorient = (vr,vc)=> whiteBottom?[vr,vc]:[7-vr,7-vc];

    function buildBoard(){
      boardEl.innerHTML='';
      for(let vr=0;vr<8;vr++){
        for(let vc=0;vc<8;vc++){
          const btn=document.createElement('button');
          btn.type='button';
          btn.className='sq '+(((vr+vc)%2===0)?'light':'dark');
          btn.dataset.r=vr; btn.dataset.c=vc;

          const piece=document.createElement('div'); piece.className='piece'; btn.appendChild(piece);
          const coord=document.createElement('div'); coord.className='coord'; btn.appendChild(coord);

          btn.addEventListener('click', onSquare);
          boardEl.appendChild(btn);
        }
      }
    }

    function render(){
      // Eval
      const liveEval = evaluate(S);
      const show = (lastEval!==null ? lastEval : liveEval);
      evalEl.textContent = formatEval(show);

      const kids=[...boardEl.children];
      for(let vr=0;vr<8;vr++){
        for(let vc=0;vc<8;vc++){
          const r=whiteBottom?vr:7-vr, c=whiteBottom?vc:7-vc;
          const tile=kids[idx(vr,vc)];
          const pieceEl = tile.querySelector('.piece');
          const coordEl = tile.querySelector('.coord');

          const p=pieceAt(S,r,c);
          pieceEl.textContent = p ? PIECE_TO_CHAR[p] : '';

          tile.classList.remove('sel','hint','move','check');

          coordEl.textContent = (vr===7 ? "abcdefgh"[c] : "") + (vc===0 ? (8-r) : "");

          if(S.lastMove){
            const [fr,fc]=S.lastMove.from,[tr,tc]=S.lastMove.to;
            if((fr===r&&fc===c)||(tr===r&&tc===c)) tile.classList.add('move');
          }
        }
      }
      if(selected){
        const [sr,sc]=selected; const [svr,svc]=orient(sr,sc);
        kids[idx(svr,svc)].classList.add('sel');
        for(const h of hints){ const [tr,tc]=h.to; const [tvr,tvc]=orient(tr,tc); kids[idx(tvr,tvc)].classList.add('hint'); }
      }
      renderCaptured(); renderMoves();

      const legal=allMoves(S);
      if(!legal.length){
        if(inCheck(S,S.turn)) status(`<b>Checkmate.</b> ${S.turn==='w'?'White':'Black'} is mated. ${S.turn==='w'?'Black':'White'} wins.`);
        else status(`<b>Stalemate.</b> Draw.`);
        pauseClock();
      } else {
        status(`Turn: <b>${S.turn==='w'?'White':'Black'}</b>${inCheck(S,S.turn)?' — <span style="color:var(--check)">Check!</span>':''}`);
      }
      updateClockDom();
      sizeBoard(); // keep square after reflow
    }

    function renderCaptured(){
      const start=fenToState(START_FEN), cnt=(St)=>{ const m={w:{Q:0,R:0,B:0,N:0,P:0},b:{Q:0,R:0,B:0,N:0,P:0}}; for(let i=0;i<64;i++){ const p=St.board[i]; if(p&&p[1]!=='K') m[p[0]][p[1]]++; } return m; };
      const have=cnt(S), base=cnt(start), out=[];
      for(const side of ['w','b']) for(const t of ['Q','R','B','N','P']){ const d=base[side][t]-have[side][t]; for(let i=0;i<d;i++) out.push(PIECE_TO_CHAR[side+t]); }
      capturedEl.innerHTML = out.map(x=>`<span>${x}</span>`).join('');
    }
    function renderMoves(){
      const lines=[]; let n=1;
      for(const h of S.history){
        if(h.turn==='w') lines.push(`${n}. ${uci(h.lastMove)} `);
        else { lines[lines.length-1]=(lines[lines.length-1]||'')+`${uci(h.lastMove)}`; n++; }
      }
      movesEl.textContent = lines.join('\n');
    }
    function uci(m){ if(!m)return''; const [fr,fc]=m.from,[tr,tc]=m.to; let s=alg(fr,fc)+alg(tr,tc); if(m.promo)s+='='+m.promo; if(m.castle)s+=' '+(m.castle==='K'?'(O-O)':'(O-O-O)'); if(m.ep)s+=' e.p.'; return s; }

    async function onSquare(e){
      if(S.turn!==humanColor) return;
      const vr=+e.currentTarget.dataset.r, vc=+e.currentTarget.dataset.c;
      const [r,c]=deorient(vr,vc); const here=pieceAt(S,r,c);

      if(selected){
        const target=hints.find(h=>h.to[0]===r && h.to[1]===c);
        if(target){
          let move={...target, from:selected, to:[r,c]};
          if(move.promo){
            const choice=await choosePromotion(S.turn);
            if(!choice){ selected=null; hints=[]; render(); return; }
            move.promo=choice;
          }
          doMove(S,move); selected=null; hints=[]; lastEval=null; render();
          requestAnimationFrame(()=>{ if(allMoves(S).length) aiTurn(); });
          return;
        }
      }
      if(here && here[0]===S.turn && here[0]===humanColor){
        selected=[r,c]; const all=allMoves(S); hints=all.filter(m=>m.from[0]===r && m.from[1]===c); render();
      } else { selected=null; hints=[]; render(); }
    }

    function aiTurn(){
      const mv=pickMove(S, levelSel.value);
      if(!mv){ render(); return; }
      doMove(S,mv); render();
    }

    function choosePromotion(turn){
      if(!hasDialog){
        const ans=(prompt("Promote to (q,r,b,n)?","q")||"q").toLowerCase(); const map={q:'Q',r:'R',b:'B',n:'N'}; return Promise.resolve(map[ans]||'Q');
      }
      return new Promise(resolve=>{
        promoGrid.innerHTML='';
        for(const t of ['Q','R','B','N']){ const b=document.createElement('button'); b.textContent = turn==='w'?PIECE_TO_CHAR['w'+t]:PIECE_TO_CHAR['b'+t]; b.onclick=()=>{ promoDialog.close(); resolve(t); }; promoGrid.appendChild(b); }
        cancelPromo.onclick=()=>{ promoDialog.close(); resolve(null); };
        promoDialog.showModal();
      });
    }

    function newGame(){
      S=fenToState(START_FEN); selected=null; hints=[]; lastEval=null;
      humanColor = (sideSel.value==='white')?'w':'b';
      buildBoard(); render();
      status(`Game started. You are <b>${humanColor==='w'?'White':'Black'}</b>. Level: <b>${levelSel.value}</b>.`);
      resetClock();
      if(S.turn!==humanColor) setTimeout(aiTurn, 120);
    }

    // Events
    newBtn.addEventListener('click', newGame);
    undoBtn.addEventListener('click', ()=>{
      if(!S.history.length) return;
      undoMove(S);
      if(S.turn!==humanColor && S.history.length) undoMove(S);
      lastEval=null; render();
    });
    flipBtn.addEventListener('click', ()=>{ whiteBottom=!whiteBottom; render(); });

    startPauseBtn.addEventListener('click', ()=>{
      if(!running){ startClock(); } else { pauseClock(); }
    });
    resetClockBtn.addEventListener('click', resetClock);
    timeSel.addEventListener('change', ()=>{ resetClock(); });

    // Boot
    setBaseClock(+timeSel.value||0);
    buildBoard(); newGame();
  </script>
</body>
</html>
