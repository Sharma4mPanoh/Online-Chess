<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Web Chess — Beginner & Expert</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f1220;
      --panel:#171a2b;
      --accent:#77e0ff;
      --accent-2:#9bff77;
      --light:#e6ecff;
      --danger:#ff7a7a;
      --square-dark:#3c4a6b;
      --square-light:#b9c6ea;
      --hint:#ffe28a;
      --move:#87ffa0;
      --sel:#ffd166;
      --shadow:0 10px 30px rgba(0,0,0,.25);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100dvh; color:var(--light); background:
        radial-gradient(1200px 1200px at 80% -10%, #2c3a66 0%, #121528 60%, #0c0f1e 100%) fixed;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      display:grid; place-items:center; padding:20px;
    }
    .app{
      width: min(1080px, 98vw);
      display:grid; grid-template-columns: 1fr 340px; gap:18px;
    }
    @media (max-width: 980px){
      .app{grid-template-columns: 1fr}
    }
    .board-wrap{
      background:linear-gradient(180deg,#1c2242,#12172f);
      padding:18px; border-radius:var(--radius); box-shadow:var(--shadow);
      display:grid; grid-template-rows:auto 1fr auto; gap:12px;
    }
    .bar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap;
    }
    .bar h1{font-size:18px; letter-spacing:.3px; margin:0; opacity:.9}
    .controls{display:flex; gap:8px; flex-wrap:wrap}
    .chip, select, button{
      background:var(--panel); border:1px solid #2a3158; color:var(--light);
      padding:8px 12px; border-radius:12px; font-weight:600; letter-spacing:.3px;
    }
    button.primary{border-color:#2f6fee; background:#2b3564}
    button:hover, select:hover{filter:brightness(1.1)}
    button:active{transform:translateY(1px)}
    .board{
      width:100%; aspect-ratio:1/1; display:grid; grid-template-columns:repeat(8,1fr);
      border-radius:14px; overflow:hidden; border:2px solid #2a3158;
      user-select:none;
    }
    .sq{
      position:relative; display:grid; place-items:center; font-size: clamp(28px, 5vw, 54px);
      line-height:1; cursor:pointer;
    }
    .light{ background: var(--square-light) }
    .dark{ background: var(--square-dark) }
    .sq .coord{
      position:absolute; left:6px; top:4px; font-size:12px; opacity:.5; color:#0e1326; font-weight:700;
      mix-blend-mode: soft-light;
    }
    .sq.dark .coord{ color:#cdd7ff; mix-blend-mode:normal; opacity:.35 }
    .sq.sel{outline:3px solid var(--sel); z-index:2}
    .sq.move{ box-shadow: inset 0 0 0 4px rgba(135,255,160,.85) }
    .sq.hint::after{
      content:""; width:16px; height:16px; border-radius:50%; background:var(--hint);
      opacity:.9; box-shadow:0 0 0 4px rgba(0,0,0,.12);
    }
    .sq.last{ box-shadow: inset 0 0 0 4px rgba(119,224,255,.8) }
    .sq.check{ box-shadow: inset 0 0 0 4px var(--danger) }
    .right{
      background:linear-gradient(180deg,#141831,#0f132a); border:1px solid #2a3158;
      border-radius:var(--radius); box-shadow:var(--shadow); padding:16px; display:grid; gap:14px; align-content:start;
    }
    .right h2{font-size:16px; margin:0 0 4px 0; opacity:.9}
    .status{
      background:#0d1125; border:1px solid #2a3158; border-radius:12px; padding:12px; min-height:48px
    }
    .captured{display:flex; gap:6px; flex-wrap:wrap; font-size:20px; opacity:.9}
    .legend{display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-size:13px; opacity:.8}
    .legend span{display:inline-flex; align-items:center; gap:6px}
    .dot{width:12px; height:12px; border-radius:50%}
    .dot.hl{background:var(--hint)} .dot.mv{background:var(--move)} .dot.sel{background:var(--sel)} .dot.ck{background:var(--danger)}
    .moves{
      background:#0d1125; border:1px solid #2a3158; border-radius:12px; padding:10px; height:260px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      font-size:13px; line-height:1.55;
    }
    .foot{font-size:12px; opacity:.75}
    /* Promotion modal */
    dialog{ border:none; border-radius:16px; padding:0; overflow:hidden; box-shadow:var(--shadow); background:#101632; color:var(--light) }
    .modal{padding:14px 16px; display:grid; gap:12px}
    .promo-grid{ display:grid; grid-template-columns: repeat(4, 60px); gap:8px; justify-content:center }
    .promo-grid button{font-size:28px; padding:10px; background:#1b244b; border:1px solid #2a3158; border-radius:12px; cursor:pointer}
    .promo-grid button:hover{filter:brightness(1.1)}
    .backdrop{backdrop-filter: blur(4px)}
  </style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div class="bar">
        <h1>♟ Web Chess</h1>
        <div class="controls">
          <label class="chip">Side:
            <select id="side">
              <option value="white">White</option>
              <option value="black">Black</option>
            </select>
          </label>
          <label class="chip">Level:
            <select id="level">
              <option value="beginner">Beginner</option>
              <option value="expert" selected>Expert</option>
            </select>
          </label>
          <button id="new" class="primary">New Game</button>
          <button id="undo">Undo</button>
          <button id="flip">Flip</button>
        </div>
      </div>

      <div id="board" class="board" aria-label="Chessboard"></div>

      <div class="bar">
        <div class="legend">
          <span><span class="dot hl"></span>Hints</span>
          <span><span class="dot mv"></span>Last move</span>
          <span><span class="dot sel"></span>Selection</span>
          <span><span class="dot ck"></span>Check</span>
        </div>
        <div id="eval" class="chip" title="Positive means advantage for White">Eval: —</div>
      </div>
    </div>

    <aside class="right">
      <div>
        <h2>Status</h2>
        <div id="status" class="status">Welcome! Choose a side & level, then press <b>New Game</b>.</div>
      </div>
      <div>
        <h2>Captured</h2>
        <div id="captured" class="captured"></div>
      </div>
      <div>
        <h2>Move List</h2>
        <div id="moves" class="moves" aria-live="polite"></div>
      </div>
      <div class="foot">
        Tip: Click a piece, then a highlighted square. Promotions will ask what you want.
      </div>
    </aside>
  </div>

  <!-- Promotion Modal -->
  <dialog id="promoDialog" class="backdrop">
    <div class="modal">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <strong>Choose promotion</strong>
        <button id="cancelPromo" class="chip">Cancel</button>
      </div>
      <div class="promo-grid" id="promoGrid"></div>
    </div>
  </dialog>

  <script>
    /**************
     * Chess Core *
     **************/
    const PIECE_TO_CHAR = {
      wP:'♙', wN:'♘', wB:'♗', wR:'♖', wQ:'♕', wK:'♔',
      bP:'♟', bN:'♞', bB:'♝', bR:'♜', bQ:'♛', bK:'♚'
    };
    const PIECE_VALUE = { P:100, N:320, B:330, R:500, Q:900, K:20000 };
    const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

    // Piece-square tables (simplified; white perspective; black mirrored)
    const PST = {
      P:[ 0,0,0,0,0,0,0,0,
          50,50,50,50,50,50,50,50,
          10,10,20,30,30,20,10,10,
          5,5,10,25,25,10,5,5,
          0,0,0,20,20,0,0,0,
          5,-5,-10,0,0,-10,-5,5,
          5,10,10,-20,-20,10,10,5,
          0,0,0,0,0,0,0,0 ],
      N:[ -50,-40,-30,-30,-30,-30,-40,-50,
          -40,-20,0,0,0,0,-20,-40,
          -30,0,10,15,15,10,0,-30,
          -30,5,15,20,20,15,5,-30,
          -30,0,15,20,20,15,0,-30,
          -30,5,10,15,15,10,5,-30,
          -40,-20,0,5,5,0,-20,-40,
          -50,-40,-30,-30,-30,-30,-40,-50 ],
      B:[ -20,-10,-10,-10,-10,-10,-10,-20,
          -10,0,0,0,0,0,0,-10,
          -10,0,5,10,10,5,0,-10,
          -10,5,5,10,10,5,5,-10,
          -10,0,10,10,10,10,0,-10,
          -10,10,10,10,10,10,10,-10,
          -10,5,0,0,0,0,5,-10,
          -20,-10,-10,-10,-10,-10,-10,-20 ],
      R:[ 0,0,0,5,5,0,0,0,
          -5,0,0,0,0,0,0,-5,
          -5,0,0,0,0,0,0,-5,
          -5,0,0,0,0,0,0,-5,
          -5,0,0,0,0,0,0,-5,
          -5,0,0,0,0,0,0,-5,
          5,10,10,10,10,10,10,5,
          0,0,0,0,0,0,0,0 ],
      Q:[ -20,-10,-10,-5,-5,-10,-10,-20,
          -10,0,0,0,0,0,0,-10,
          -10,0,5,5,5,5,0,-10,
          -5,0,5,5,5,5,0,-5,
          0,0,5,5,5,5,0,-5,
          -10,5,5,5,5,5,0,-10,
          -10,0,5,0,0,0,0,-10,
          -20,-10,-10,-5,-5,-10,-10,-20 ],
      K:[ -30,-40,-40,-50,-50,-40,-40,-30,
          -30,-40,-40,-50,-50,-40,-40,-30,
          -30,-40,-40,-50,-50,-40,-40,-30,
          -30,-40,-40,-50,-50,-40,-40,-30,
          -20,-30,-30,-40,-40,-30,-30,-20,
          -10,-20,-20,-20,-20,-20,-20,-10,
          20,20,0,0,0,0,20,20,
          20,30,10,0,0,10,30,20 ]
    };

    // Helpers
    const idx = (r,c)=> r*8 + c;
    const inb = (r,c)=> r>=0 && r<8 && c>=0 && c<8;
    const clone = obj => structuredClone ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));
    const algebraic = (r,c)=> "abcdefgh"[c] + (8-r);
    const coordOf = sq => [8-parseInt(sq[1]), "abcdefgh".indexOf(sq[0])];

    function fenToState(fen){
      const [piece, turn, cast, ep, half, full] = fen.split(/\s+/);
      const rows = piece.split('/');
      const board = Array(64).fill(null);
      rows.forEach((row, r)=>{
        let c=0;
        for(const ch of row){
          if(/\d/.test(ch)){ c += parseInt(ch,10); }
          else{
            const color = (ch===ch.toUpperCase())?'w':'b';
            const tp = ch.toUpperCase();
            const map = {P:'P',N:'N',B:'B',R:'R',Q:'Q',K:'K'};
            board[idx(r,c)] = color + map[tp];
            c++;
          }
        }
      });
      const cr = {wK:false,wQ:false,bK:false,bQ:false};
      if(cast.includes('K')) cr.wK=true;
      if(cast.includes('Q')) cr.wQ=true;
      if(cast.includes('k')) cr.bK=true;
      if(cast.includes('q')) cr.bQ=true;
      return {
        board, turn, castling:cr,
        ep: ep==='-'? null : ep,
        halfmove: parseInt(half||'0',10),
        fullmove: parseInt(full||'1',10),
        history:[]
      };
    }

    function stateToFEN(S){
      let s=""; for(let r=0;r<8;r++){
        let empty=0;
        for(let c=0;c<8;c++){
          const p=S.board[idx(r,c)];
          if(!p) empty++;
          else{
            if(empty){ s+=empty; empty=0; }
            const [cl,pt] = [p[0],p[1]];
            const chMap = {P:'p',N:'n',B:'b',R:'r',Q:'q',K:'k'};
            s += cl==='w' ? chMap[pt].toUpperCase() : chMap[pt];
          }
        }
        if(empty) s+=empty;
        if(r<7) s+='/';
      }
      const c = (S.castling.wK?'K':'')+(S.castling.wQ?'Q':'')+(S.castling.bK?'k':'')+(S.castling.bQ?'q':'');
      return [
        s,
        S.turn,
        c===""?'-':c,
        S.ep?S.ep:'-',
        S.halfmove,
        S.fullmove
      ].join(' ');
    }

    function pieceAt(S, r,c){ return S.board[idx(r,c)] }
    function putPiece(S,r,c,p){ S.board[idx(r,c)] = p }
    function swapTurn(S){ S.turn = (S.turn==='w'?'b':'w') }

    function allMoves(S){
      // Generate pseudo-legal moves, then legality is checked by make/undo & inCheck
      const moves=[];
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const p=pieceAt(S,r,c); if(!p||p[0]!==S.turn) continue;
        const pt=p[1];
        if(pt==='P') genPawn(S,r,c,moves);
        else if(pt==='N') genKnight(S,r,c,moves);
        else if(pt==='B') genSlider(S,r,c,moves,[[1,1],[1,-1],[-1,1],[-1,-1]]);
        else if(pt==='R') genSlider(S,r,c,moves,[[1,0],[-1,0],[0,1],[0,-1]]);
        else if(pt==='Q') genSlider(S,r,c,moves,[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]);
        else if(pt==='K') genKing(S,r,c,moves);
      }
      // filter legal
      const legal=[];
      for(const m of moves){
        doMove(S,m);
        const inC = inCheck(S, S.turn==='w'?'b':'w');
        undoMove(S);
        if(!inC) legal.push(m);
      }
      return legal;
    }

    function genPawn(S,r,c,out){
      const dir = S.turn==='w' ? -1 : 1;
      const startRow = S.turn==='w'?6:1;
      const lastRow  = S.turn==='w'?0:7;

      // advance 1
      if(inb(r+dir,c) && !pieceAt(S,r+dir,c)){
        pushPawnMove(r,c,r+dir,c);
        // advance 2
        if(r===startRow && !pieceAt(S,r+2*dir,c)) push({from:[r,c],to:[r+2*dir,c],pawn2:true});
      }
      // captures
      for(const dc of [-1,1]){
        const nr=r+dir, nc=c+dc;
        if(!inb(nr,nc)) continue;
        const t=pieceAt(S,nr,nc);
        if(t && t[0]!==S.turn){ pushPawnMove(r,c,nr,nc,t) }
      }
      // en passant
      if(S.ep){
        const [er, ec] = coordOf(S.ep);
        if(er===r+dir && Math.abs(ec-c)===1){
          // capture target square en passant
          push({from:[r,c],to:[er,ec],ep:true});
        }
      }

      function pushPawnMove(fr,fc,tr,tc,captured=null){
        const promo = (tr===lastRow);
        if(promo){
          for(const toP of ['Q','R','B','N']) out.push({from:[fr,fc],to:[tr,tc],captured, promo:toP});
        }else{
          out.push({from:[fr,fc],to:[tr,tc],captured});
        }
      }
      function push(m){ out.push(m) }
    }

    function genKnight(S,r,c,out){
      const steps=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      for(const [dr,dc] of steps){
        const nr=r+dr, nc=c+dc; if(!inb(nr,nc)) continue;
        const t=pieceAt(S,nr,nc);
        if(!t || t[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:t||null});
      }
    }

    function genSlider(S,r,c,out,dirs){
      for(const [dr,dc] of dirs){
        let nr=r+dr, nc=c+dc;
        while(inb(nr,nc)){
          const t=pieceAt(S,nr,nc);
          if(!t){ out.push({from:[r,c],to:[nr,nc]}); }
          else{
            if(t[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:t});
            break;
          }
          nr+=dr; nc+=dc;
        }
      }
    }

    function genKing(S,r,c,out){
      for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
        if(!dr && !dc) continue;
        const nr=r+dr, nc=c+dc; if(!inb(nr,nc)) continue;
        const t=pieceAt(S,nr,nc);
        if(!t || t[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:t||null});
      }
      // castling
      const clr=S.turn;
      const back = (clr==='w')?7:0;
      if(r===back && c===4){
        // King side
        if((clr==='w' && S.castling.wK) || (clr==='b' && S.castling.bK)){
          if(!pieceAt(S,back,5) && !pieceAt(S,back,6)){
            if(!isSquareAttacked(S,[back,4],opp(clr)) && !isSquareAttacked(S,[back,5],opp(clr)) && !isSquareAttacked(S,[back,6],opp(clr))){
              out.push({from:[back,4],to:[back,6],castle:'K'});
            }
          }
        }
        // Queen side
        if((clr==='w' && S.castling.wQ) || (clr==='b' && S.castling.bQ)){
          if(!pieceAt(S,back,3) && !pieceAt(S,back,2) && !pieceAt(S,back,1)){
            if(!isSquareAttacked(S,[back,4],opp(clr)) && !isSquareAttacked(S,[back,3],opp(clr)) && !isSquareAttacked(S,[back,2],opp(clr))){
              out.push({from:[back,4],to:[back,2],castle:'Q'});
            }
          }
        }
      }
    }

    function opp(c){ return c==='w'?'b':'w' }

    function isSquareAttacked(S, [tr,tc], by){
      // Pawns
      const dir = by==='w'?-1:1;
      for(const dc of [-1,1]){
        const r=tr+dir, c=tc+dc;
        if(inb(r,c)){ const p=pieceAt(S,r,c); if(p && p===(by+'P')) return true; }
      }
      // Knights
      const steps=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      for(const [dr,dc] of steps){
        const r=tr+dr, c=tc+dc; if(inb(r,c)){ const p=pieceAt(S,r,c); if(p && p===(by+'N')) return true; }
      }
      // Bishops/Queens
      const bDirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
      if(ray(by,'B',bDirs)) return true;
      // Rooks/Queens
      const rDirs=[[1,0],[-1,0],[0,1],[0,-1]];
      if(ray(by,'R',rDirs)) return true;
      // King
      for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
        if(!dr && !dc) continue;
        const r=tr+dr, c=tc+dc; if(inb(r,c)){ const p=pieceAt(S,r,c); if(p && p===(by+'K')) return true; }
      }
      return false;

      function ray(color, type, dirs){
        for(const [dr,dc] of dirs){
          let r=tr+dr, c=tc+dc;
          while(inb(r,c)){
            const p=pieceAt(S,r,c);
            if(p){
              if(p[0]===color){
                if(p[1]===type || p[1]==='Q') return true;
              }
              break;
            }
            r+=dr; c+=dc;
          }
        }
        return false;
      }
    }

    function inCheck(S, who){
      // find king
      let kr=-1,kc=-1;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        if(pieceAt(S,r,c)===(who+'K')){ kr=r; kc=c; }
      }
      return isSquareAttacked(S,[kr,kc], opp(who));
    }

    function doMove(S, m){
      // record snapshot
      const snap = {
        board: S.board.slice(),
        turn: S.turn,
        castling: {...S.castling},
        ep: S.ep,
        halfmove: S.halfmove,
        fullmove: S.fullmove,
        lastMove: m
      };
      S.history.push(snap);

      const [fr,fc]=m.from, [tr,tc]=m.to;
      const moving = pieceAt(S,fr,fc);
      const target = pieceAt(S,tr,tc);

      // halfmove clock
      if(moving[1]==='P' || target) S.halfmove=0; else S.halfmove++;

      // en passant capture
      if(m.ep){
        const [er,ec]=coordOf(S.ep);
        if(m.ep && tr===er && tc===ec){
          // remove captured pawn
          const capr = S.turn==='w' ? tr+1 : tr-1;
          putPiece(S, capr, tc, null);
        }
      }

      // move piece
      putPiece(S, tr, tc, moving);
      putPiece(S, fr, fc, null);

      // castling move rook
      if(m.castle==='K'){
        const back = S.turn==='w'?7:0;
        const rookFrom=[back,7], rookTo=[back,5];
        const rook = pieceAt(S,rookFrom[0],rookFrom[1]);
        putPiece(S, rookTo[0], rookTo[1], rook);
        putPiece(S, rookFrom[0], rookFrom[1], null);
      } else if(m.castle==='Q'){
        const back = S.turn==='w'?7:0;
        const rookFrom=[back,0], rookTo=[back,3];
        const rook = pieceAt(S,rookFrom[0],rookFrom[1]);
        putPiece(S, rookTo[0], rookTo[1], rook);
        putPiece(S, rookFrom[0], rookFrom[1], null);
      }

      // promotion
      if(m.promo){
        putPiece(S, tr, tc, S.turn + m.promo);
      }

      // update castling rights
      if(moving==='wK'){ S.castling.wK=false; S.castling.wQ=false }
      if(moving==='bK'){ S.castling.bK=false; S.castling.bQ=false }
      if(moving==='wR'){
        if(fr===7 && fc===0) S.castling.wQ=false;
        if(fr===7 && fc===7) S.castling.wK=false;
      }
      if(moving==='bR'){
        if(fr===0 && fc===0) S.castling.bQ=false;
        if(fr===0 && fc===7) S.castling.bK=false;
      }
      // if rook captured
      if(target==='wR'){
        if(tr===7 && tc===0) S.castling.wQ=false;
        if(tr===7 && tc===7) S.castling.wK=false;
      }
      if(target==='bR'){
        if(tr===0 && tc===0) S.castling.bQ=false;
        if(tr===0 && tc===7) S.castling.bK=false;
      }

      // set en passant target
      if(m.pawn2){
        const epRow = S.turn==='w' ? tr+1 : tr-1;
        S.ep = algebraic(epRow, tc);
      } else {
        S.ep = null;
      }

      if(S.turn==='b') S.fullmove++;
      swapTurn(S);
      S.lastMove = {from:[fr,fc],to:[tr,tc]};
    }

    function undoMove(S){
      const prev = S.history.pop(); if(!prev) return;
      S.board = prev.board;
      S.turn = prev.turn;
      S.castling = prev.castling;
      S.ep = prev.ep;
      S.halfmove = prev.halfmove;
      S.fullmove = prev.fullmove;
      S.lastMove = prev.lastMove;
    }

    /*****************
     * AI / Search   *
     *****************/
    function evaluate(S){
      // material + PST + mobility (very light)
      let score=0;
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        const p=pieceAt(S,r,c); if(!p) continue;
        const side = (p[0]==='w')?1:-1;
        const type = p[1];
        score += side * PIECE_VALUE[type];
        // PST
        let sqIndex = r*8+c;
        let table = PST[type];
        if(p[0]==='w'){
          score += table[sqIndex];
        }else{
          // mirror for black
          const mr = 7-r, mc = c;
          score -= table[mr*8+mc];
        }
      }
      // mobility
      const t= S.turn;
      const ms = allMoves(S).length;
      S.turn = opp(S.turn);
      const os = allMoves(S).length;
      S.turn = t;
      score += 2*(ms - os);
      return score;
    }

    function pickMove(S, level){
      const moves = allMoves(S);
      if(moves.length===0) return null;
      if(level==='beginner'){
        // random among legal (slightly prefer captures)
        const caps = moves.filter(m=>m.captured);
        if(caps.length) return caps[Math.floor(Math.random()*caps.length)];
        return moves[Math.floor(Math.random()*moves.length)];
      }
      // expert: alpha-beta depth 3 (adaptive to 4 if fast board)
      const depth = 3;
      let bestScore = -1e9, best = moves[0];
      orderMoves(moves);
      for(const m of moves){
        doMove(S,m);
        const sc = -alphabeta(S, depth-1, -1e9, 1e9);
        undoMove(S);
        if(sc>bestScore){ bestScore=sc; best=m; }
      }
      lastEval = bestScore;
      return best;

      function alphabeta(S, d, alpha, beta){
        const mv = allMoves(S);
        if(d===0 || mv.length===0) return quiesce(S, alpha, beta, 8);
        orderMoves(mv);
        let val = -1e9;
        for(const m of mv){
          doMove(S,m);
          val = Math.max(val, -alphabeta(S, d-1, -beta, -alpha));
          undoMove(S);
          if(val>=beta) return val;
          if(val>alpha) alpha=val;
        }
        return val;
      }
      function quiesce(S, alpha, beta, capBudget){
        const stand = evaluate(S);
        if(stand>=beta) return stand;
        if(alpha<stand) alpha=stand;
        if(capBudget<=0) return stand;
        const caps = allMoves(S).filter(m=>m.captured);
        orderMoves(caps);
        for(const m of caps){
          doMove(S,m);
          const score = -quiesce(S, -beta, -alpha, capBudget-1);
          undoMove(S);
          if(score>=beta) return score;
          if(score>alpha) alpha=score;
        }
        return alpha;
      }
      function orderMoves(mv){
        // MVV-LVA and promotions, simple ordering
        mv.sort((a,b)=> scoreMove(b)-scoreMove(a));
        function valOf(p){ return p?PIECE_VALUE[p[1]]:0 }
        function scoreMove(m){
          let s=0;
          if(m.captured) s += 1000 + valOf(m.captured);
          if(m.promo) s += 800 + PIECE_VALUE[m.promo];
          if(m.castle) s += 200;
          return s;
        }
      }
    }

    /*****************
     * UI Rendering  *
     *****************/
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const evalEl = document.getElementById('eval');
    const movesEl = document.getElementById('moves');
    const capturedEl = document.getElementById('captured');
    const levelSel = document.getElementById('level');
    const sideSel = document.getElementById('side');
    const newBtn = document.getElementById('new');
    const undoBtn = document.getElementById('undo');
    const flipBtn = document.getElementById('flip');
    const promoDialog = document.getElementById('promoDialog');
    const promoGrid = document.getElementById('promoGrid');
    const cancelPromo = document.getElementById('cancelPromo');

    let S = fenToState(START_FEN);
    let selected = null;      // [r,c] or null
    let hints = [];           // list of {to:[r,c], ...}
    let whiteBottom = true;   // board orientation
    let lastEval = null;
    let humanColor = 'w';
    let pendingPromotion = null; // {move, resolve}

    function newGame(){
      S = fenToState(START_FEN);
      selected=null; hints=[]; lastEval=null;
      humanColor = (sideSel.value==='white')?'w':'b';
      render(true);
      status("Game started. You are <b>"+(humanColor==='w'?'White':'Black')+"</b>. Level: <b>"+levelSel.value+"</b>.");
      if(S.turn!==humanColor) setTimeout(aiTurn, 200);
    }

    function render(rebuild=false){
      // captured
      renderCaptured();
      // eval
      evalEl.textContent = "Eval: " + (lastEval===null ? "—" : (lastEval/100).toFixed(2));
      // board
      if(rebuild){
        boardEl.innerHTML="";
        for(let vr=0; vr<8; vr++){
          for(let vc=0; vc<8; vc++){
            const d=document.createElement('div'); d.className='sq '+(((vr+vc)%2===0)?'light':'dark');
            d.dataset.r=vr; d.dataset.c=vc;
            const coord=document.createElement('div'); coord.className='coord';
            d.appendChild(coord);
            d.addEventListener('click', onSquare);
            boardEl.appendChild(d);
          }
        }
      }
      // paint squares according to orientation
      const kids = [...boardEl.children];
      for(let vr=0; vr<8; vr++){
        for(let vc=0; vc<8; vc++){
          const r = whiteBottom ? vr : 7-vr;
          const c = whiteBottom ? vc : 7-vc;
          const tile = kids[idx(vr,vc)];
          const p = pieceAt(S,r,c);
          tile.textContent = p ? PIECE_TO_CHAR[p] : '';
          tile.classList.remove('sel','hint','move','last','check');
          tile.querySelector('.coord').textContent =
            (vr===7 ? "abcdefgh"[c] : "") + (vc===0 ? (8-r) : "");
          // last move mark
          if(S.lastMove){
            const [fr,fc] = S.lastMove.from, [tr,tc]=S.lastMove.to;
            if(fr===r&&fc===c) tile.classList.add('move');
            if(tr===r&&tc===c) tile.classList.add('move');
          }
          // check mark on king
          const kPos = findKing(S, S.turn);
          if(kPos && inCheck(S,S.turn)){
            const [kr,kc]=kPos;
            if(kr===r && kc===c) tile.classList.add('check');
          }
        }
      }
      // show selection & hints
      if(selected){
        const [sr,sc] = selected;
        const [vr,vc] = orient(sr,sc);
        kids[idx(vr,vc)].classList.add('sel');
        for(const h of hints){
          const [tr,tc] = h.to;
          const [vr2,vc2] = orient(tr,tc);
          kids[idx(vr2,vc2)].classList.add('hint');
        }
      }
      // moves list
      renderMoves();
      // status turn
      if(allMoves(S).length===0){
        if(inCheck(S,S.turn)){
          status(`<b>Checkmate.</b> ${S.turn==='w'?'White':'Black'} is mated. ${S.turn==='w'?'Black':'White'} wins.`);
        }else{
          status(`<b>Stalemate.</b> Draw.`);
        }
      } else {
        status(`Turn: <b>${S.turn==='w'?'White':'Black'}</b>${inCheck(S,S.turn)?' — <span style="color:var(--danger)">Check!</span>':''}`);
      }
    }

    function renderCaptured(){
      // compute captured comparing to starting material
      const startCounts = countMaterial(fenToState(START_FEN));
      const nowCounts = countMaterial(S);
      const out=[];
      for(const side of ['w','b']){
        for(const t of ['Q','R','B','N','P']){
          const diff = startCounts[side][t] - nowCounts[side][t];
          if(diff>0){
            for(let i=0;i<diff;i++) out.push(PIECE_TO_CHAR[side+t]);
          }
        }
      }
      capturedEl.innerHTML = out.map(x=>`<span>${x}</span>`).join('');
      function countMaterial(St){
        const m={w:{Q:0,R:0,B:0,N:0,P:0}, b:{Q:0,R:0,B:0,N:0,P:0}};
        for(let i=0;i<64;i++){
          const p=St.board[i]; if(!p) continue;
          if(p[1]!=='K') m[p[0]][p[1]]++;
        }
        return m;
      }
    }

    function renderMoves(){
      // very simple: show UCI of moves in history
      const lines=[];
      let moveNo=1;
      for(const h of S.history){
        if(h.turn==='w'){
          lines.push(`${moveNo}. ${uci(h.lastMove)} `);
        } else {
          lines[lines.length-1] = (lines[lines.length-1]||"") + `${uci(h.lastMove)}`;
          moveNo++;
        }
      }
      movesEl.innerHTML = lines.join('<br/>');
    }

    function uci(m){
      if(!m) return '';
      const [fr,fc]=m.from, [tr,tc]=m.to;
      let s = algebraic(fr,fc) + algebraic(tr,tc);
      if(m.promo) s += "="+m.promo;
      if(m.castle) s += m.castle==='K'?' (O-O)':' (O-O-O)';
      if(m.ep) s += " e.p.";
      return s;
    }

    function findKing(S, color){
      for(let r=0;r<8;r++) for(let c=0;c<8;c++){
        if(pieceAt(S,r,c)===(color+'K')) return [r,c];
      }
      return null;
    }

    function orient(r,c){
      return whiteBottom ? [r,c] : [7-r, 7-c];
    }
    function deorient(vr,vc){
      return whiteBottom ? [vr,vc] : [7-vr, 7-vc];
    }

    function status(html){
      statusEl.innerHTML = html;
    }

    async function onSquare(e){
      // ignore if AI's turn
      if(S.turn!==humanColor) return;

      const vr = parseInt(e.currentTarget.dataset.r,10);
      const vc = parseInt(e.currentTarget.dataset.c,10);
      const [r,c] = deorient(vr,vc);
      const here = pieceAt(S,r,c);

      if(selected){
        // try move if in hints
        const target = hints.find(h=> h.to[0]===r && h.to[1]===c);
        if(target){
          // Handle promotion if needed
          let moveToPlay = {...target, from:selected, to:[r,c]};
          if(moveToPlay.promo){
            const choice = await choosePromotion(S.turn);
            if(!choice){ selected=null; hints=[]; render(); return; }
            moveToPlay.promo = choice;
          }
          doMove(S, moveToPlay);
          render();
          window.requestAnimationFrame(()=>{
            if(allMoves(S).length>0) aiTurn();
          });
          return;
        }
      }
      // (re)select if your piece
      if(here && here[0]===S.turn && here[0]===humanColor){
        selected = [r,c];
        const all = allMoves(S);
        hints = all.filter(m=> m.from[0]===r && m.from[1]===c);
        render();
      } else {
        selected=null; hints=[]; render();
      }
    }

    function aiTurn(){
      const level = levelSel.value;
      const mv = pickMove(S, level);
      if(!mv){
        render();
        return;
      }
      doMove(S, mv);
      render();
    }

    function choosePromotion(turn){
      return new Promise(resolve=>{
        pendingPromotion = {resolve};
        promoGrid.innerHTML = '';
        const opts = (turn==='w')? ['Q','R','B','N'].map(t=>['w'+t, PIECE_TO_CHAR['w'+t]])
                                  : ['Q','R','B','N'].map(t=>['b'+t, PIECE_TO_CHAR['b'+t]]);
        for(const [code, sym] of opts){
          const btn=document.createElement('button');
          btn.textContent = sym;
          btn.addEventListener('click', ()=>{
            promoDialog.close(); pendingPromotion.resolve(code[1]); pendingPromotion=null;
          });
          promoGrid.appendChild(btn);
        }
        cancelPromo.onclick = ()=>{ promoDialog.close(); pendingPromotion.resolve(null); pendingPromotion=null; }
        promoDialog.showModal();
      });
    }

    newBtn.addEventListener('click', newGame);
    undoBtn.addEventListener('click', ()=>{
      // Undo two plies if last was AI
      if(S.history.length===0) return;
      undoMove(S);
      if(S.turn!==humanColor && S.history.length>0) undoMove(S);
      render();
    });
    flipBtn.addEventListener('click', ()=>{ whiteBottom=!whiteBottom; render(true) });

    // Auto-start as White Expert
    newGame();
  </script>
</body>
</html>
