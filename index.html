<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Web Chess — Beginner & Expert (stable)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --panel:#171a2b; --light:#e6ecff; --danger:#ff7a7a;
      --square-dark:#3c4a6b; --square-light:#b9c6ea;
      --hint:#ffe28a; --sel:#ffd166;
      --shadow:0 10px 30px rgba(0,0,0,.25); --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100dvh; color:var(--light);
      background: radial-gradient(1200px 1200px at 80% -10%, #2c3a66 0%, #121528 60%, #0c0f1e 100%) fixed;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      display:grid; place-items:center; padding:20px;
    }
    .app{ width:min(1080px,98vw); display:grid; grid-template-columns: 1fr 340px; gap:18px; }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr } }
    .board-wrap{ background:linear-gradient(180deg,#1c2242,#12172f); padding:18px; border-radius:var(--radius); box-shadow:var(--shadow); display:grid; grid-template-rows:auto 1fr auto; gap:12px; }
    .bar{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .bar h1{font-size:18px; margin:0; opacity:.9}
    .chip, select, button{
      background:var(--panel); border:1px solid #2a3158; color:var(--light);
      padding:8px 12px; border-radius:12px; font-weight:600;
    }
    button.primary{background:#2b3564; border-color:#2f6fee}
    button:hover, select:hover{filter:brightness(1.08)}
    .board{
      width:100%; aspect-ratio:1/1; display:grid; grid-template-columns:repeat(8,1fr);
      border-radius:14px; overflow:hidden; border:2px solid #2a3158; user-select:none;
    }
    .sq{ position:relative; display:grid; place-items:center; cursor:pointer; }
    .sq .piece{ font-size: clamp(28px, 5vw, 54px); line-height:1 }
    .light{ background: var(--square-light) }
    .dark{ background: var(--square-dark) }
    .coord{ position:absolute; left:6px; top:4px; font-size:12px; opacity:.5; color:#0e1326; font-weight:700; mix-blend-mode: soft-light; }
    .dark .coord{ color:#cdd7ff; mix-blend-mode:normal; opacity:.35 }
    .sq.sel{outline:3px solid var(--sel); z-index:2}
    .sq.move{ box-shadow: inset 0 0 0 4px rgba(119,224,255,.8) }
    .sq.hint::after{ content:""; width:16px; height:16px; border-radius:50%; background:var(--hint); opacity:.95; box-shadow:0 0 0 4px rgba(0,0,0,.12); }
    .sq.check{ box-shadow: inset 0 0 0 4px var(--danger) }
    .right{ background:linear-gradient(180deg,#141831,#0f132a); border:1px solid #2a3158; border-radius:var(--radius); box-shadow:var(--shadow); padding:16px; display:grid; gap:14px; align-content:start; }
    .status{ background:#0d1125; border:1px solid #2a3158; border-radius:12px; padding:12px; min-height:48px }
    .moves{ background:#0d1125; border:1px solid #2a3158; border-radius:12px; padding:10px; height:260px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size:13px; line-height:1.55; white-space:pre-wrap }
    dialog{ border:none; border-radius:16px; padding:0; overflow:hidden; box-shadow:var(--shadow); background:#101632; color:var(--light) }
    .modal{padding:14px 16px; display:grid; gap:12px}
    .promo-grid{ display:grid; grid-template-columns: repeat(4, 60px); gap:8px; justify-content:center }
    .promo-grid button{font-size:28px; padding:10px; background:#1b244b; border:1px solid #2a3158; border-radius:12px; cursor:pointer}
  </style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div class="bar">
        <h1>♟ Web Chess</h1>
        <div class="controls">
          <label class="chip">Side:
            <select id="side">
              <option value="white">White</option>
              <option value="black">Black</option>
            </select>
          </label>
          <label class="chip">Level:
            <select id="level">
              <option value="beginner">Beginner</option>
              <option value="expert" selected>Expert</option>
            </select>
          </label>
          <button id="new" class="primary">New Game</button>
          <button id="undo">Undo</button>
          <button id="flip">Flip</button>
        </div>
      </div>

      <div id="board" class="board" aria-label="Chessboard"></div>

      <div class="bar">
        <div class="chip">Eval: <span id="eval">—</span></div>
        <div id="status" class="chip">Welcome! Choose side & level, then press <b>New Game</b>.</div>
      </div>
    </div>

    <aside class="right">
      <div><b>Captured</b><div id="captured" style="margin-top:6px;font-size:20px;display:flex;gap:6px;flex-wrap:wrap"></div></div>
      <div><b>Move List</b><div id="moves" class="moves" aria-live="polite"></div></div>
      <div style="font-size:12px;opacity:.75">Tip: Click a piece, then a highlighted square. Promotions will ask what you want.</div>
    </aside>
  </div>

  <!-- Promotion Modal (has prompt() fallback if <dialog> unsupported) -->
  <dialog id="promoDialog">
    <div class="modal">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <strong>Choose promotion</strong>
        <button id="cancelPromo" class="chip">Cancel</button>
      </div>
      <div class="promo-grid" id="promoGrid"></div>
    </div>
  </dialog>

  <script>
    /* ---------- Safe utilities ---------- */
    const safeClone = (obj) =>
      (typeof window.structuredClone === "function")
        ? window.structuredClone(obj)
        : JSON.parse(JSON.stringify(obj));
    const hasDialog = typeof HTMLDialogElement !== "undefined";
    (function(){ if(!window.console){ window.console = {log:()=>{}, warn:()=>{}, error:()=>{}} } })();

    /* ---------- Chess Core ---------- */
    const PIECE_TO_CHAR = { wP:'♙', wN:'♘', wB:'♗', wR:'♖', wQ:'♕', wK:'♔', bP:'♟', bN:'♞', bB:'♝', bR:'♜', bQ:'♛', bK:'♚' };
    const PIECE_VALUE = { P:100, N:320, B:330, R:500, Q:900, K:20000 };
    const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    const PST = {
      P:[0,0,0,0,0,0,0,0,50,50,50,50,50,50,50,50,10,10,20,30,30,20,10,10,5,5,10,25,25,10,5,5,0,0,0,20,20,0,0,0,5,-5,-10,0,0,-10,-5,5,5,10,10,-20,-20,10,10,5,0,0,0,0,0,0,0,0],
      N:[-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
      B:[-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
      R:[0,0,0,5,5,0,0,0,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,-5,0,0,0,0,0,0,-5,5,10,10,10,10,10,10,5,0,0,0,0,0,0,0,0],
      Q:[-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10,-5,0,5,5,5,5,0,-5,0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
      K:[-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10,20,20,0,0,0,0,20,20,20,30,10,0,0,10,30,20]
    };
    const idx=(r,c)=>r*8+c, inb=(r,c)=>r>=0&&r<8&&c>=0&&c<8, alg=(r,c)=>"abcdefgh"[c]+(8-r), opp=c=>c==='w'?'b':'w';
    const coordOf = sq => [8-parseInt(sq[1]), "abcdefgh".indexOf(sq[0])];

    function fenToState(f){
      const [piece,turn,cast,ep,half,full]=f.split(/\s+/); const rows=piece.split('/'); const board=Array(64).fill(null);
      rows.forEach((row,r)=>{ let c=0; for(const ch of row){ if(/\d/.test(ch)) c+=+ch; else{ const clr=(ch===ch.toUpperCase())?'w':'b'; board[idx(r,c)]=clr+ch.toUpperCase(); c++; } }});
      const cr={wK:false,wQ:false,bK:false,bQ:false}; if(cast.includes('K'))cr.wK=true; if(cast.includes('Q'))cr.wQ=true; if(cast.includes('k'))cr.bK=true; if(cast.includes('q'))cr.bQ=true;
      return {board, turn, castling:cr, ep: ep==='-'?null:ep, halfmove:+(half||0), fullmove:+(full||1), history:[], lastMove:null};
    }
    const pieceAt=(S,r,c)=>S.board[idx(r,c)];
    const put=(S,r,c,p)=>{S.board[idx(r,c)]=p};
    function isAttacked(S,[tr,tc],by){
      const dir=by==='w'?-1:1;
      for(const dc of [-1,1]){ const r=tr+dir,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'P')) return true; }
      for(const [dr,dc] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const r=tr+dr,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'N')) return true; }
      const rays=(dirs,types)=>{ for(const [dr,dc] of dirs){ let r=tr+dr,c=tc+dc; while(inb(r,c)){ const p=pieceAt(S,r,c); if(p){ if(p[0]===by && (types.includes(p[1])||p[1]==='Q')) return true; break; } r+=dr;c+=dc; } } return false };
      if(rays([[1,1],[1,-1],[-1,1],[-1,-1]],['B'])) return true;
      if(rays([[1,0],[-1,0],[0,1],[0,-1]],['R'])) return true;
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc)continue; const r=tr+dr,c=tc+dc; if(inb(r,c)&&pieceAt(S,r,c)===(by+'K')) return true; }
      return false;
    }
    function inCheck(S,who){ for(let r=0;r<8;r++)for(let c=0;c<8;c++){ if(pieceAt(S,r,c)===(who+'K')) return isAttacked(S,[r,c],opp(who)); } return false; }
    function allMoves(S){
      const out=[];
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=pieceAt(S,r,c); if(!p||p[0]!==S.turn) continue;
        const t=p[1];
        if(t==='P'){ const dir=S.turn==='w'?-1:1, start=S.turn==='w'?6:1, last=S.turn==='w'?0:7;
          if(inb(r+dir,c)&&!pieceAt(S,r+dir,c)){ pushPawn(r,c,r+dir,c); if(r===start && !pieceAt(S,r+2*dir,c)) out.push({from:[r,c],to:[r+2*dir,c],pawn2:true}); }
          for(const dc of [-1,1]){ const nr=r+dir,nc=c+dc; if(!inb(nr,nc))continue; const t=pieceAt(S,nr,nc); if(t&&t[0]!==S.turn) pushPawn(r,c,nr,nc,t); }
          if(S.ep){ const [er,ec]=coordOf(S.ep); if(er===r+dir && Math.abs(ec-c)===1) out.push({from:[r,c],to:[er,ec],ep:true}); }
          function pushPawn(fr,fc,tr,tc,captured=null){ const promo=tr===last; if(promo){ for(const pp of ['Q','R','B','N']) out.push({from:[fr,fc],to:[tr,tc],captured,promo:pp}); } else out.push({from:[fr,fc],to:[tr,tc],captured}); }
        } else if(t==='N'){ for(const [dr,dc] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const nr=r+dr,nc=c+dc; if(!inb(nr,nc))continue; const q=pieceAt(S,nr,nc); if(!q||q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q||null}); } }
        else if(t==='B'||t==='R'||t==='Q'){ const dirs=t==='B'?[[1,1],[1,-1],[-1,1],[-1,-1]]:t==='R'?[[1,0],[-1,0],[0,1],[0,-1]]:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(inb(nr,nc)){ const q=pieceAt(S,nr,nc); if(!q) out.push({from:[r,c],to:[nr,nc]}); else { if(q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q}); break; } nr+=dr; nc+=dc; } }
        } else if(t==='K'){ for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(!dr&&!dc)continue; const nr=r+dr,nc=c+dc; if(!inb(nr,nc))continue; const q=pieceAt(S,nr,nc); if(!q||q[0]!==S.turn) out.push({from:[r,c],to:[nr,nc],captured:q||null}); }
          const clr=S.turn, back=clr==='w'?7:0;
          if(r===back&&c===4){
            if((clr==='w'&&S.castling.wK)||(clr==='b'&&S.castling.bK)){
              if(!pieceAt(S,back,5)&&!pieceAt(S,back,6)&&!isAttacked(S,[back,4],opp(clr))&&!isAttacked(S,[back,5],opp(clr))&&!isAttacked(S,[back,6],opp(clr))) out.push({from:[back,4],to:[back,6],castle:'K'});
            }
            if((clr==='w'&&S.castling.wQ)||(clr==='b'&&S.castling.bQ)){
              if(!pieceAt(S,back,3)&&!pieceAt(S,back,2)&&!pieceAt(S,back,1)&&!isAttacked(S,[back,4],opp(clr))&&!isAttacked(S,[back,3],opp(clr))&&!isAttacked(S,[back,2],opp(clr))) out.push({from:[back,4],to:[back,2],castle:'Q'});
            }
          }
        }
      }
      const legal=[];
      for(const m of out){ doMove(S,m); const bad=inCheck(S,opp(S.turn)); undoMove(S); if(!bad) legal.push(m); }
      return legal;
    }
    function doMove(S,m){
      S.history.push({board:S.board.slice(), turn:S.turn, castling:{...S.castling}, ep:S.ep, halfmove:S.halfmove, fullmove:S.fullmove, lastMove:m});
      const [fr,fc]=m.from,[tr,tc]=m.to; const moving=pieceAt(S,fr,fc), target=pieceAt(S,tr,tc);
      if(moving[1]==='P'||target) S.halfmove=0; else S.halfmove++;
      if(S.ep){ const [er,ec]=coordOf(S.ep); if(m.ep&&tr===er&&tc===ec){ const capr=S.turn==='w'?tr+1:tr-1; put(S,capr,tc,null); } }
      put(S,tr,tc,moving); put(S,fr,fc,null);
      if(m.castle==='K'){ const back=S.turn==='w'?7:0; const rook=pieceAt(S,back,7); put(S,back,5,rook); put(S,back,7,null); }
      else if(m.castle==='Q'){ const back=S.turn==='w'?7:0; const rook=pieceAt(S,back,0); put(S,back,3,rook); put(S,back,0,null); }
      if(m.promo) put(S,tr,tc,S.turn+m.promo);
      if(moving==='wK'){S.castling.wK=false;S.castling.wQ=false}
      if(moving==='bK'){S.castling.bK=false;S.castling.bQ=false}
      if(moving==='wR'){ if(fr===7&&fc===0)S.castling.wQ=false; if(fr===7&&fc===7)S.castling.wK=false }
      if(moving==='bR'){ if(fr===0&&fc===0)S.castling.bQ=false; if(fr===0&&fc===7)S.castling.bK=false }
      if(target==='wR'){ if(tr===7&&tc===0)S.castling.wQ=false; if(tr===7&&tc===7)S.castling.wK=false }
      if(target==='bR'){ if(tr===0&&tc===0)S.castling.bQ=false; if(tr===0&&tc===7)S.castling.bK=false }
      S.ep = m.pawn2 ? alg(S.turn==='w'?tr+1:tr-1, tc) : null;
      if(S.turn==='b') S.fullmove++; S.turn=opp(S.turn); S.lastMove={...m};
    }
    function undoMove(S){ const h=S.history.pop(); if(!h) return; Object.assign(S,{board:h.board,turn:h.turn,castling:h.castling,ep:h.ep,halfmove:h.halfmove,fullmove:h.fullmove,lastMove:h.lastMove}); }
    function evaluate(S){
      let sc=0;
      for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=pieceAt(S,r,c); if(!p)continue; const s=p[0]==='w'?1:-1, t=p[1];
        sc+=s*PIECE_VALUE[t]; sc+= (p[0]==='w'? 1:-1) * (p[0]==='w'? PST[t][r*8+c] : -PST[t][(7-r)*8+c]);
      }
      const t=S.turn, ms=allMoves(S).length; S.turn=opp(S.turn); const os=allMoves(S).length; S.turn=t; sc+=2*(ms-os);
      return sc;
    }
    function pickMove(S, level){
      const moves=allMoves(S); if(!moves.length) return null;
      if(level==='beginner'){ const caps=moves.filter(m=>m.captured); return (caps.length?caps:moves)[Math.floor(Math.random()*(caps.length?caps.length:moves.length))]; }
      const depth=3; let best=-1e9, choice=moves[0];
      order(moves);
      for(const m of moves){ doMove(S,m); const sc=-ab(S,depth-1,-1e9,1e9); undoMove(S); if(sc>best){best=sc; choice=m;} }
      lastEval=best; return choice;
      function ab(S,d,a,b){ const mv=allMoves(S); if(d===0||!mv.length) return q(S,a,b,8); order(mv); let v=-1e9; for(const m of mv){ doMove(S,m); v=Math.max(v,-ab(S,d-1,-b,-a)); undoMove(S); if(v>=b) return v; if(v>a) a=v; } return v; }
      function q(S,a,b,bud){ const stand=evaluate(S); if(stand>=b) return stand; if(a<stand)a=stand; if(bud<=0) return stand; const caps=allMoves(S).filter(m=>m.captured); order(caps); for(const m of caps){ doMove(S,m); const s=-q(S,-b,-a,bud-1); undoMove(S); if(s>=b) return s; if(s>a)a=s; } return a; }
      function order(mv){ mv.sort((A,B)=>score(B)-score(A)); function v(p){return p?PIECE_VALUE[p[1]]:0} function score(m){ let s=0; if(m.captured)s+=1000+v(m.captured); if(m.promo)s+=800+PIECE_VALUE[m.promo]; if(m.castle)s+=200; return s; } }
    }

    /* ---------- UI ---------- */
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const evalEl = document.getElementById('eval');
    const movesEl = document.getElementById('moves');
    const capturedEl = document.getElementById('captured');
    const levelSel = document.getElementById('level');
    const sideSel = document.getElementById('side');
    const newBtn = document.getElementById('new');
    const undoBtn = document.getElementById('undo');
    const flipBtn = document.getElementById('flip');
    const promoDialog = document.getElementById('promoDialog');
    const promoGrid = document.getElementById('promoGrid');
    const cancelPromo = document.getElementById('cancelPromo');

    let S = fenToState(START_FEN);
    let selected = null, hints = [], whiteBottom = true, lastEval = null, humanColor = 'w';

    function status(html){ statusEl.innerHTML = html; }
    const orient = (r,c)=> whiteBottom?[r,c]:[7-r,7-c];
    const deorient = (vr,vc)=> whiteBottom?[vr,vc]:[7-vr,7-vc];

    function buildBoard(){
      boardEl.innerHTML='';
      for(let vr=0;vr<8;vr++){
        for(let vc=0;vc<8;vc++){
          const btn=document.createElement('button');
          btn.type='button';
          btn.className='sq '+(((vr+vc)%2===0)?'light':'dark');
          btn.dataset.r=vr; btn.dataset.c=vc;

          const piece=document.createElement('div');
          piece.className='piece'; btn.appendChild(piece);

          const coord=document.createElement('div');
          coord.className='coord'; btn.appendChild(coord);

          btn.addEventListener('click', onSquare);
          boardEl.appendChild(btn);
        }
      }
    }

    function render(){
      // eval
      evalEl.textContent = (lastEval===null ? '—' : (lastEval/100).toFixed(2));

      // board
      const kids=[...boardEl.children];
      for(let vr=0;vr<8;vr++){
        for(let vc=0;vc<8;vc++){
          const r=whiteBottom?vr:7-vr, c=whiteBottom?vc:7-vc;
          const tile=kids[idx(vr,vc)];
          const pieceEl = tile.querySelector('.piece');
          const coordEl = tile.querySelector('.coord');

          // glyph
          const p=pieceAt(S,r,c);
          pieceEl.textContent = p ? PIECE_TO_CHAR[p] : '';

          // classes
          tile.classList.remove('sel','hint','move','check');

          // coords
          coordEl.textContent = (vr===7 ? "abcdefgh"[c] : "") + (vc===0 ? (8-r) : "");

          // last move
          if(S.lastMove){
            const [fr,fc]=S.lastMove.from,[tr,tc]=S.lastMove.to;
            if((fr===r&&fc===c)||(tr===r&&tc===c)) tile.classList.add('move');
          }
        }
      }

      // selection + hints
      if(selected){
        const [sr,sc]=selected; const [svr,svc]=orient(sr,sc);
        kids[idx(svr,svc)].classList.add('sel');
        for(const h of hints){ const [tr,tc]=h.to; const [tvr,tvc]=orient(tr,tc); kids[idx(tvr,tvc)].classList.add('hint'); }
      }

      // captured & moves
      renderCaptured(); renderMoves();

      // status
      const legal=allMoves(S);
      if(!legal.length){
        status(inCheck(S,S.turn) ? `<b>Checkmate.</b> ${S.turn==='w'?'White':'Black'} is mated.` : `<b>Stalemate.</b> Draw.`);
      } else {
        status(`Turn: <b>${S.turn==='w'?'White':'Black'}</b>${inCheck(S,S.turn)?' — <span style="color:var(--danger)">Check!</span>':''}`);
      }
    }

    function renderCaptured(){
      const start=fenToState(START_FEN), cnt=(St)=>{ const m={w:{Q:0,R:0,B:0,N:0,P:0},b:{Q:0,R:0,B:0,N:0,P:0}}; for(let i=0;i<64;i++){ const p=St.board[i]; if(p&&p[1]!=='K') m[p[0]][p[1]]++; } return m; };
      const have=cnt(S), base=cnt(start), out=[];
      for(const side of ['w','b']) for(const t of ['Q','R','B','N','P']){ const d=base[side][t]-have[side][t]; for(let i=0;i<d;i++) out.push(PIECE_TO_CHAR[side+t]); }
      capturedEl.innerHTML = out.map(x=>`<span>${x}</span>`).join('');
    }
    function renderMoves(){
      const lines=[]; let n=1;
      for(const h of S.history){
        if(h.turn==='w') lines.push(`${n}. ${uci(h.lastMove) } `);
        else { lines[lines.length-1]=(lines[lines.length-1]||'')+`${uci(h.lastMove)}`; n++; }
      }
      movesEl.textContent = lines.join('\n');
    }
    function uci(m){ if(!m)return''; const [fr,fc]=m.from,[tr,tc]=m.to; let s=alg(fr,fc)+alg(tr,tc); if(m.promo)s+='='+m.promo; if(m.castle)s+=' '+(m.castle==='K'?'(O-O)':'(O-O-O)'); if(m.ep)s+=' e.p.'; return s; }

    async function onSquare(e){
      if(S.turn!==humanColor) return;
      const vr=+e.currentTarget.dataset.r, vc=+e.currentTarget.dataset.c;
      const [r,c]=deorient(vr,vc); const here=pieceAt(S,r,c);

      if(selected){
        const target=hints.find(h=>h.to[0]===r && h.to[1]===c);
        if(target){
          let move={...target, from:selected, to:[r,c]};
          if(move.promo){
            const choice=await choosePromotion(S.turn);
            if(!choice){ selected=null; hints=[]; render(); return; }
            move.promo=choice;
          }
          doMove(S,move); selected=null; hints=[]; render();
          requestAnimationFrame(()=>{ if(allMoves(S).length) aiTurn(); });
          return;
        }
      }
      if(here && here[0]===S.turn && here[0]===humanColor){
        selected=[r,c]; const all=allMoves(S); hints=all.filter(m=>m.from[0]===r && m.from[1]===c); render();
      } else { selected=null; hints=[]; render(); }
    }

    function aiTurn(){
      const mv=pickMove(S, levelSel.value);
      if(!mv){ render(); return; }
      doMove(S,mv); render();
    }

    function choosePromotion(turn){
      if(!hasDialog){
        const ans=(prompt("Promote to (q,r,b,n)?","q")||"q").toLowerCase(); const map={q:'Q',r:'R',b:'B',n:'N'}; return Promise.resolve(map[ans]||'Q');
      }
      return new Promise(resolve=>{
        promoGrid.innerHTML='';
        for(const t of ['Q','R','B','N']){ const b=document.createElement('button'); b.textContent = turn==='w'?PIECE_TO_CHAR['w'+t]:PIECE_TO_CHAR['b'+t]; b.onclick=()=>{ promoDialog.close(); resolve(t); }; promoGrid.appendChild(b); }
        cancelPromo.onclick=()=>{ promoDialog.close(); resolve(null); };
        promoDialog.showModal();
      });
    }

    function newGame(){
      S=fenToState(START_FEN); selected=null; hints=[]; lastEval=null;
      humanColor = (sideSel.value==='white')?'w':'b';
      buildBoard(); render();
      status("Game started. You are <b>"+(humanColor==='w'?'White':'Black')+"</b>. Level: <b>"+levelSel.value+"</b>.");
      if(S.turn!==humanColor) setTimeout(aiTurn, 200);
    }

    newBtn.addEventListener('click', newGame);
    undoBtn.addEventListener('click', ()=>{ if(!S.history.length) return; undoMove(S); if(S.turn!==humanColor && S.history.length) undoMove(S); render(); });
    flipBtn.addEventListener('click', ()=>{ whiteBottom=!whiteBottom; render(); });

    // Boot
    buildBoard(); newGame();
  </script>
</body>
</html>
